"""
Run Python code generated by an LLM in a given environment. Currently, supports local host and
E2B sandbox execution. Also, defines custom exceptions for security and environment errors.
"""
import re
import warnings
from typing import Optional, Literal

from . import kutils as ku


CODE_ENV_NAMES = Literal['host', 'docker', 'e2b']
"""Allowed code execution environment names."""
DEFAULT_ALLOWED_IMPORTS = {
    'ast', 'operator', 're',  # calculator
}
""" Default allowed imports for code execution."""
# Check for the use of dangerous builtins
DANGEROUS_BUILTINS = {'exec', 'eval', '__import__', 'compile'}
"""Dangerous built-in functions that are not allowed in code execution."""

logger = ku.get_logger()


class CodeSecurityError(Exception):
    """Exception raised for security violations in code execution."""


class UnknownCodeEnvError(Exception):
    """Exception raised for unknown code execution environments."""


class CodeRunner:
    """Run Python code generated by an LLM in a given environment."""
    def __init__(
            self,
            env: CODE_ENV_NAMES,
            allowed_imports: list[str],
            pip_packages: Optional[str] = None,
            timeout: int = 30,
            env_vars_to_set: Optional[dict[str, str]] = None
    ):
        """
        Create an environment to run Python code.

        Args:
            env: The code execution environment. Must be a string from `CODE_ENV_NAMES`.
            allowed_imports: A list of Python modules that are allowed to be imported.
            pip_packages: Optional Python libs to be installed by `pip` [E2B].
            timeout: Code execution timeout (default 30s).
            env_vars_to_set: Optional environment variables to set in the code execution
             environment (E2B only).
        """
        self.allowed_imports: set[str] = set(allowed_imports).union(DEFAULT_ALLOWED_IMPORTS)
        self.env: CODE_ENV_NAMES = env
        if pip_packages and len(pip_packages.strip()) > 0:
            self.pip_packages: list[str] = re.split('[,;]', pip_packages)
        else:
            self.pip_packages = []
        self.default_timeout = timeout
        self.local_modules_to_copy = []
        self.pip_packages_str = ' '.join(self.pip_packages) if self.pip_packages else None
        self.env_vars_to_set = env_vars_to_set

    def check_imports(self, code: str) -> set[str]:
        """
        Check for disallowed imports in code.

        Args:
            code: The Python source code to check.

        Returns:
            A set of disallowed imported module names.
        """
        import ast

        tree = ast.parse(code)
        imported_modules = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Name) and node.id in DANGEROUS_BUILTINS:
                raise CodeSecurityError(f'Forbidden builtin: {node.id}')

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imported_modules.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                imported_modules.add(node.module)

        disallowed = imported_modules - self.allowed_imports
        return disallowed

    def run(self, source_code: str, task_id: str) -> tuple[str, str, int]:
        """
        Run Python code in pre-specified environment.

        Args:
            source_code: The Python source code to execute.
            task_id: Unique task identifier for tracking.

        Returns:
            A tuple of (stdout, stderr, return_code).

        Raises:
            UnknownCodeEnvError: If the specified environment is unsupported.
        """
        import ast

        try:
            ast.parse(source_code)
        except SyntaxError as se:
            return (
                '',
                f'Code parsing failed due to: {type(se).__name__}\n{se.text}\nError: {str(se)}',
                -1
            )

        disallowed_imports: set = self.check_imports(source_code)
        if len(disallowed_imports) > 0:
            modules = '\n'.join([mod for mod in disallowed_imports])
            return (
                '',
                f'The following imports are disallowed:{modules}'
                '\nPlease only use the allowed modules for importing.',
                -1
            )

        if self.env == 'host':
            return self._run_code_host(source_code)

        if self.env =='e2b':
            return self._run_code_e2b(source_code, task_id)

        raise UnknownCodeEnvError(f'Unsupported code execution env: {self.env}')

    def _run_code_host(self, source_code: str) -> tuple[str, str, int]:
        """
        Run code on the host machine.

        Args:
            source_code: The Python source code to execute.

        Returns:
            A tuple of (stdout, stderr, return_code).
        """
        import os
        import shutil
        import subprocess as sp
        import sys
        import tempfile

        warnings.warn(
            'You are running LLM-generated code on your host. This could be potentially'
            ' dangerous! Please consider using a different code runner environment.',
            UserWarning
        )
        with tempfile.NamedTemporaryFile(
                mode='w+t', suffix='.py', delete=False, encoding='utf-8'
        ) as code_file:
            code_file.write(source_code)
            code_file.close()

            for a_file in self.local_modules_to_copy:
                shutil.copy2(
                    os.path.join(os.path.dirname(__file__), a_file),
                    tempfile.gettempdir()
                )

            result = sp.run(
                [sys.executable, code_file.name],
                shell=False, capture_output=True, text=True,
                timeout=self.default_timeout,
                check=False,
                encoding='utf-8'
            )
            os.remove(code_file.name)
            return result.stdout, result.stderr, result.returncode

    def _run_code_e2b(self, source_code: str, task_id: str) -> tuple[str, str, int]:
        """
        Run code in the E2B sandbox environment.

        Args:
            source_code: The Python source code to execute.
            task_id: Unique task identifier for tracking.

        Returns:
            A tuple of (stdout, stderr, return_code).
        """
        import os
        import sys

        try:
            import e2b_code_interpreter as e2b
        except ModuleNotFoundError:
            logger.critical(
                'The module `e2b_code_interpreter` was not found. Please install E2B as:'
                ' `pip install e2b-code-interpreter`\nExecution will halt now.'
            )
            sys.exit(-1)

        # Do not reuse existing sandboxes due to security reasons, as they may relate to
        # other tasks/users. Always create a fresh sandbox.
        sbx = e2b.Sandbox(
            timeout=self.default_timeout + 15,
            envs=self.env_vars_to_set or {},
            metadata={'task_id': task_id}  # Track ownership
        )
        if self.pip_packages_str:
            sbx.commands.run(f'pip install {self.pip_packages_str}')

        for a_file in self.local_modules_to_copy:
            with open(
                    os.path.join(os.path.dirname(__file__), a_file),
                    'r',
                    encoding='utf-8'
            ) as py_file:
                sbx.files.write(f'/home/user/{a_file}', py_file.read())
                logger.info('Copied file %s...', a_file)

        logger.info('E2B sandbox info: %s', sbx.get_info())
        execution = sbx.run_code(code=source_code, timeout=self.default_timeout)
        std_out: str = '\n'.join(execution.logs.stdout)
        std_err: str = '\n'.join(execution.logs.stderr)
        if execution.error:
            std_err += f'\n{execution.error.name}\n{execution.error.value}'
        ret_code: int = -1 if execution.error else 0

        return std_out, std_err, ret_code
